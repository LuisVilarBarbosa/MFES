class PrivateUser is subclass of User
types
	public static Email = Common`String1
		;--inv e == isEmail(e);
	public static Password = Common`String1
		inv p == len p >= minLength;
	public static PublicUsers = set of PublicUser;
	public static Places = set of Place;
	public static Shows = set of Calendar`Show;
	private static PrivateUsers = set of PrivateUser;
values
	private minLength = 8;
instance variables
	-- Variables declared public to facilitate queries
	public email : Email;
	public password : Password;
	public myPublicUsers : PublicUsers;
	public myPlaces : Places;
	public myShows : Shows;
	private static privateUsers : PrivateUsers := {};
operations
	public PrivateUser : Common`String1 * Email * Password ==> PrivateUser
	PrivateUser(n,e,pass) == (
		email := e;
		password := pass;
		myPublicUsers := {};
		myPlaces := {};
		myShows := {};
		privateUsers := privateUsers union {self};
		User(n);
	)
	pre forall u in set privateUsers & u.email <> e
	post privateUsers inter {self} = {self};

	public SetPassword : Password ==> ()
	SetPassword(p) == password := p
	pre len p >= minLength
	post password = p;

	public CreatePublicUser : Common`String1 * Common`Address ==> ()
	CreatePublicUser(n,addr) == myPublicUsers := myPublicUsers union {new PublicUser(n,addr)}
	;--pre myPublicUsers inter {publicUser} = {};

	public CreatePlace : Common`String1 * Common`String * Common`Address ==> ()
	CreatePlace(n,d,l) == myPlaces := myPlaces union {new Place(n,d,l)}
	;--pre myPlaces inter {p} = {}

	public RemovePlace : Place ==> ()
	RemovePlace(p) == (
		myPlaces := myPlaces \ {p};
		Place`RemovePlace(p);
	)
	pre p in set myPlaces
	post p not in set myPlaces and myPlaces~ = myPlaces union {p};

	public CreateShow : Common`String1 * Calendar`Performers * Common`Date * Common`Date * Place * Common`String ==> ()
	CreateShow(n,ps,sd,ed,pl,desc) == (
		dcl s : Calendar`Show := Calendar`CreateShow(n,ps,sd,ed,pl,desc);
		myShows := myShows union {s};
		Calendar`AddShow(s);
	)
	;--pre myShows inter {s} = {}
	--post myShows inter {s} = {s};

	public RemoveShow : Calendar`Show ==> ()
	RemoveShow(s) == (
		myShows := myShows \ {s};
		Calendar`RemoveShow(s);
	)
	pre s in set myShows
	post s not in set myShows and myShows~ = myShows union {s};
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end PrivateUser